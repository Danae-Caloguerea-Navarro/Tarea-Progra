# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1smvjhrZQBjvVMRaXMoiwht-iMFxaMcfn

##P1: Te贸rica
***驴Qu茅 es un paradigma de programaci贸n?***

En el contexto de programaci贸n, un paradigma es el estilo o m茅todo que se sigue para llevar a cabo el proyecto en cuesti贸n. Este determina c贸mo se estructura y organiza el c贸digo o c贸mo interact煤an las funciones y m茅todos entre s铆.

***驴En qu茅 se basa la programaci贸n orientada a objetos?***

La Programaci贸n Orientada a Objetos (POO) se basa en el uso de objetos y clases para organizar y estructurar el c贸digo. Se comporta como una plantilla.

Adem谩s, entrega los siguientes beneficios:

- Es adecuada para crear aplicaciones triviales y complejas.

- Permite reutilizar el c贸digo, lo que aumenta la productividad.

- Se pueden incorporar f谩cilmente nuevas funciones al c贸digo existente.

- Reduce los costes de producci贸n y mantenimiento.


***驴Cu谩l es la diferencia entre recursividad e iteraci贸n, y c贸mo se relaciona esto con la notaci贸n big ?***

En la recursividad la funci贸n se llama a ella misma para resolver sub-problemas m谩s peque帽os que el original, pero dentro de este mismo. Se necesita una condici贸n base y  se utiliza la funci贸n if. En la iteraci贸n se utiliza bucles for y while para repetir instrucciones hasta que se cumpla una condici贸n. Consume menos memoria en comparaci贸n a la recursividad.
En cuanto a la relaci贸n con big O, la recursividad es menos eficiente en tiempo debido a llamadas repetitivas de la funci贸n, en cambio la iteraci贸n tiende a ser m谩s eficiente.


***Explicar la diferencia de rendimiento entre (1) y ()***

 Para (1) el tiempo de ejecuci贸n es constante, esto quiere decir que el
algoritmo realiza siempre la misma cantidad de trabajo, independiente si la entrada es peque帽o o grande. En cambio, en el () su tiempo de ejecuci贸n aumenta con la entrada, es decir no es constante. Por lo tanto, hablando de rendimiento el  (1) tiene mejor rendimiento.

***驴C贸mo se calcula el orden en un programa que funciona por etapas?***

 Se calcula la complejidad temporal considerando las complejidades de cada etapa y sum谩ndolas o multiplic谩ndolas seg煤n su relaci贸n. Se suman cuando las etapas son ejecutadas secuencialmente, es decir, una despu茅s de la otra. En este caso la complejidad total, ser铆a la suma de las complejidades de cada etapa. El razonamiento con la multiplicaci贸n es an谩logo y se utiliza cuando las etapas est谩n anidadas. Finalmente, el orden total del programa ser谩 la etapa con mayor complejidad.

***驴C贸mo se puede determinar la complejidad temporal de un algoritmo recursivo?***

La complejidad temporal de un algoritmo recursivo se determina expresando el problema como una recurrencia y resolvi茅ndola para obtener el tiempo total de ejecuci贸n, es decir a mayor recurrencias mayor ser谩 la complejidad.
"""

import time
import matplotlib.pyplot as plt

#Definici贸n de clase
class PCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M
        self.time_log = {} #se utilizar谩 para medir el tiempo de ejecuci贸n de cada funci贸n.

#funci贸n para calcular el tiempo
    def tiempo(self, func, *args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        elapsed_time = end_time - start_time
        self.time_log[func.__name__] = elapsed_time
        return result

#definici贸n del primer m茅todo, utilizando n para almacenar la cuenta
    def recursive(self, i=0, j=0, n=None):
        if n is None:
            n = {}
        if (i, j) in n:
            return n[(i, j)]
        if i == self.N - 1 and j == self.M - 1:
            return 1
        if i >= self.N or j >= self.M:
            return 0
        n[(i, j)] = self.recursive(i + 1, j, n) + self.recursive(i, j + 1, n)
        return n[(i, j)]

#definici贸n del segundo m茅todo
    def iterativo(self):
        dp = [[0] * self.M for _ in range(self.N)]
        for i in range(self.N):
            for j in range(self.M):
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[self.N - 1][self.M - 1]

#Funci贸n para relacionar el tiempo y caminos
    def caminos(self, solution):
        if solution == 'recursive':
            return self.tiempo(self.recursive)
        elif solution == 'dp':
            return self.tiempo(self.iterativo)
        else:
            raise ValueError("Soluci贸n no reconocida. Use 'recursive' o 'dp'.")

    def show_time_log(self):
        return self.time_log

def Gr谩fico():
    sizes = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10,10)]
    recursive_times = []
    dp_times = []
    inputs = []

    for N, M in sizes:
        pcb = PCB(N, M)
        print(f"Probando con tama帽o: {N}x{M}")
        inputs.append(N * M)

        # Tiempo de la soluci贸n recursiva con memoizaci贸n
        pcb.caminos('recursive')
        recursive_times.append(pcb.show_time_log().get('recursive', float('inf')))

        # Tiempo de la soluci贸n din谩mica
        pcb.caminos('dp')
        dp_times.append(pcb.show_time_log().get('iterativo', float('inf')))

    plt.figure(figsize=(10, 6))

    plt.scatter(inputs, recursive_times, color='blue', label='M茅todo Recursivo', marker='o')
    plt.scatter(inputs, dp_times, color='green', label='M茅todo Iterativo', marker='x')

    #definici贸n de t铆tulo y  ejes
    plt.title('Tiempos de Ejecuci贸n de Soluciones para Diferentes Tama帽os de PCB')
    plt.xlabel('Tama帽o de PCB (N * M)')
    plt.ylabel('Tiempo de Ejecuci贸n (segundos)')
    plt.legend()
    plt.grid(True)  # A帽adido para mejor visualizaci贸n
    plt.show()

# Llamar a la funci贸n para generar el gr谩fico
Gr谩fico()