# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1smvjhrZQBjvVMRaXMoiwht-iMFxaMcfn

##P1: Teórica
***¿Qué es un paradigma de programación?***

En el contexto de programación, un paradigma es el estilo o método que se sigue para llevar a cabo el proyecto en cuestión. Este determina cómo se estructura y organiza el código o cómo interactúan las funciones y métodos entre sí.

***¿En qué se basa la programación orientada a objetos?***

La Programación Orientada a Objetos (POO) se basa en el uso de objetos y clases para organizar y estructurar el código. Se comporta como una plantilla.

Además, entrega los siguientes beneficios:

- Es adecuada para crear aplicaciones triviales y complejas.

- Permite reutilizar el código, lo que aumenta la productividad.

- Se pueden incorporar fácilmente nuevas funciones al código existente.

- Reduce los costes de producción y mantenimiento.


***¿Cuál es la diferencia entre recursividad e iteración, y cómo se relaciona esto con la notación big 𝑂?***

En la recursividad la función se llama a ella misma para resolver sub-problemas más pequeños que el original, pero dentro de este mismo. Se necesita una condición base y  se utiliza la función if. En la iteración se utiliza bucles for y while para repetir instrucciones hasta que se cumpla una condición. Consume menos memoria en comparación a la recursividad.
En cuanto a la relación con big O, la recursividad es menos eficiente en tiempo debido a llamadas repetitivas de la función, en cambio la iteración tiende a ser más eficiente.


***Explicar la diferencia de rendimiento entre 𝑂(1) y 𝑂(𝑛)***

 Para 𝑂(1) el tiempo de ejecución es constante, esto quiere decir que el
algoritmo realiza siempre la misma cantidad de trabajo, independiente si la entrada es pequeño o grande. En cambio, en el 𝑂(𝑛) su tiempo de ejecución aumenta con la entrada, es decir no es constante. Por lo tanto, hablando de rendimiento el  𝑂(1) tiene mejor rendimiento.

***¿Cómo se calcula el orden en un programa que funciona por etapas?***

 Se calcula la complejidad temporal considerando las complejidades de cada etapa y sumándolas o multiplicándolas según su relación. Se suman cuando las etapas son ejecutadas secuencialmente, es decir, una después de la otra. En este caso la complejidad total, sería la suma de las complejidades de cada etapa. El razonamiento con la multiplicación es análogo y se utiliza cuando las etapas están anidadas. Finalmente, el orden total del programa será la etapa con mayor complejidad.

***¿Cómo se puede determinar la complejidad temporal de un algoritmo recursivo?***

La complejidad temporal de un algoritmo recursivo se determina expresando el problema como una recurrencia y resolviéndola para obtener el tiempo total de ejecución, es decir a mayor recurrencias mayor será la complejidad.
"""

import time
import matplotlib.pyplot as plt

#Definición de clase
class PCB:
    def __init__(self, N, M):
        self.N = N
        self.M = M
        self.time_log = {} #se utilizará para medir el tiempo de ejecución de cada función.

#función para calcular el tiempo
    def tiempo(self, func, *args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        elapsed_time = end_time - start_time
        self.time_log[func.__name__] = elapsed_time
        return result

#definición del primer método, utilizando n para almacenar la cuenta
    def recursive(self, i=0, j=0, n=None):
        if n is None:
            n = {}
        if (i, j) in n:
            return n[(i, j)]
        if i == self.N - 1 and j == self.M - 1:
            return 1
        if i >= self.N or j >= self.M:
            return 0
        n[(i, j)] = self.recursive(i + 1, j, n) + self.recursive(i, j + 1, n)
        return n[(i, j)]

#definición del segundo método
    def iterativo(self):
        dp = [[0] * self.M for _ in range(self.N)]
        for i in range(self.N):
            for j in range(self.M):
                if i == 0 or j == 0:
                    dp[i][j] = 1
                else:
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[self.N - 1][self.M - 1]

#Función para relacionar el tiempo y caminos
    def caminos(self, solution):
        if solution == 'recursive':
            return self.tiempo(self.recursive)
        elif solution == 'dp':
            return self.tiempo(self.iterativo)
        else:
            raise ValueError("Solución no reconocida. Use 'recursive' o 'dp'.")

    def show_time_log(self):
        return self.time_log

def Gráfico():
    sizes = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (9, 9), (10,10)]
    recursive_times = []
    dp_times = []
    inputs = []

    for N, M in sizes:
        pcb = PCB(N, M)
        print(f"Probando con tamaño: {N}x{M}")
        inputs.append(N * M)

        # Tiempo de la solución recursiva con memoización
        pcb.caminos('recursive')
        recursive_times.append(pcb.show_time_log().get('recursive', float('inf')))

        # Tiempo de la solución dinámica
        pcb.caminos('dp')
        dp_times.append(pcb.show_time_log().get('iterativo', float('inf')))

    plt.figure(figsize=(10, 6))

    plt.scatter(inputs, recursive_times, color='blue', label='Método Recursivo', marker='o')
    plt.scatter(inputs, dp_times, color='green', label='Método Iterativo', marker='x')

    #definición de título y  ejes
    plt.title('Tiempos de Ejecución de Soluciones para Diferentes Tamaños de PCB')
    plt.xlabel('Tamaño de PCB (N * M)')
    plt.ylabel('Tiempo de Ejecución (segundos)')
    plt.legend()
    plt.grid(True)  # Añadido para mejor visualización
    plt.show()

# Llamar a la función para generar el gráfico
Gráfico()